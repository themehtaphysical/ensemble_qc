#########################################################
# 
# T1IR_1H_Exp4
#
# A pulse sequence suitable for performing a
# T1IR_1H_Exp4-IR experiment
#
# 180pulse - delay - 90pulse - acq
#
# Copyright (c) Magritek Ltd 2022
#
# U.I. V5
#########################################################

#########################################################
# 
# The is the entry point for the SpinsolveExpert 
# interface. It will add the experiment to the parameter
# list or with the control key pressed open the
# relevant macros in the pulse program compiler.
#
# Autogenerated 
#
#########################################################

procedure(T1IR_1H_Exp4, parameters=null)

   macroLocation = getmacropath()
   parentPath = getbasepath(macroLocation)
   ppGroup = getbasedir(parentPath)

   if(iskeypressed("shift"))
      PulseProgramCompiler(guiwinnr(),null,parentPath,"T1IR_1H_Exp4")
   elseif(iskeypressed("control"))
      gView->showExperimentHelp("T1IR_1H_Exp4")
   else
      gExpt->addExperiment(ppGroup,"T1IR_1H_Exp4",parameters)
   endif

endproc()

#########################################################
# 
# Provide a backdoor interface to this macro. This 
# adds ["w1","aRF"] to the user interface list (guipar)
# and also generates the pulse program lists required 
# by execpp. Finally is calls execpp, returning any
# results in the structure 'r'.
#
# Autogenerated 
#
#########################################################

procedure(backdoor, guipar)

   seqInfo = :getseqpar()  
   r = gSeq->initAndRunPP(getmacropath(), getmacroname(), guipar, seqInfo)

endproc(r)

#########################################################
# 
# Returns important pulse sequence parameter lists
#
# rel ......... relationship between pulse sequence parameters
# var ......... variable which change during the pulse sequence
# pp_list ..... list of pulse sequence parameters sent to DSP
# pp_name ..... name of DSP pulse program to run
# phase_list .. phase cycling information
#
# Autogenerated 
#
#########################################################

procedure(getseqpar)

   rel = ["nPnts      = nrPnts",
          "aRF        = 90Amplitude1H",
          "aRF2       = 90Amplitude1H",
          "d90        = pulseLength1H",
          "d180       = pulseLength1H*2",
          "w1         = maxDelay*1000-d90-pgo",
          "dAcq       = ucsUtilities:getacqDelay(pulseLength1H,shiftPoints,dwellTime)",
          "dRng       = satDelay",
          "offFreq1H  = (centerFreqPPM-wvPPMOffset1H)*b1Freq1H",
          "O1         = offFreq1H",
          "totPnts    = nrPnts",
          "totTime    = acqTime"]
   var = ["w1","aRF"]
   pp_list = ["aRF","p1","d90","dRng","w1","aRF2","dAcq","nPnts"]
   pp_name = "T1IR_1H_Exp4.p"
   phase_list = [0;2;1;3;0]

   seqInfo = struct(rel,var,pp_list,pp_name,phase_list)

endproc(seqInfo)


#######################################################
# Execute the pulse program, collecting nrScans of 
# data and displaying the result in the 1D plot. 
#
# This procedure can be modified to perform more
# complex functions using the passed parameters:
#
# guipar ..... all parameters from the user interface
# ppList ..... the pulse program parameter list
# pcList ..... phase-cycle list
# pcIndex .... indices of phase parameters in ppList
# varIndex ... indices of variable parameters in ppList
#
# Feb 2021 CDE
#######################################################

procedure(execpp,guipar,ppList,pcList,pcIndex,varIndex)

# Make all gui parameters available
   assignlist(guipar)

# Calculate suitable time and frequency axes
   tAxis = ([0:1:totPnts-1]/totPnts)*totTime*1000            # ms
   fAxis = ([0:1:zf*totPnts-1]-zf*totPnts/2)/totTime/zf*1000 # Hz

# Time domain filter
   if(filter == "yes")
      flt = filters:get_filter(filterType,"FTFid",tAxis/1e6)
   else
      flt = matrix(totPnts)+1
   endif

# Get plot regions
  (prt,prf,prs,pri) = ucsPlot:getPlotReferences()
   prt->showimag("true")
   prf->showimag("false")

# Work out frequency axis scale, label and range
   (fAxisDisp,fAxisLabel,fRange) = ucsPlot:generate1DFrequencyAxis(prf, fAxis, b1Freq1H, wvPPMOffset1H, offFreq1H, guipar)

# Allocate memory for output data
   echoDelay  = matrix(nrSteps)
   echoInt    = matrix(nrSteps)
   echoError  = matrix(nrSteps)
  # spec2d     = cmatrix(nrPnts*zf,nrSteps)
   data2d     = cmatrix(totPnts,nrSteps)
   sumData    = cmatrix(totPnts)

# Make the delay array
   if(delaySpacing == "log")
      dArray = logspace(minDelay,maxDelay,nrSteps)*1000
   else
      dArray = linspace(minDelay,maxDelay,nrSteps)*1000
   endif

# Check the integration range
   if(size(bulkInt) != 2)
      message("Error","Integration range parameter should have two values","error")
      return(0)
   endif

   if(bulkInt[0] > bulkInt[1])
      message("Error","Integration range parameter is reversed","error")
      return(0)
   endif

# Parameters to be shared
   IntegrateRegions:initSharedData(fAxisDisp,nrPnts*zf,nrSteps,dArray/1000,bulkInt) 

# Initialise phase correction
   pc = 1 

# Intialise progress bar
  # if(convertToExp == "yes")
 #     startIndx = -2
 #  else
      startIndx = -1
 #  endif
  
# Loop over the delay array   
   for(d = startIndx to nrSteps-1)

   # Update the pulse amplitude and T1IR_1H_Exp4 delay parameters
      if(d == -2) # Make reference/phase scan
         dly = 100 # Plenty of ringdown time
         amp = -85
         tm = 100
      elseif(d == -1) # Short time dummy/phase scan
         dly = round(dArray[0])-d90-pgo
         tm = dArray[0]/1000
         amp = 90Amplitude1H
      else # Normal experiment
         dly = round(dArray[d])-d90-pgo
         tm = dArray[d]/1000
         amp = 90Amplitude1H
      endif

      ppList = ucsRun:setPPLongDelay(ppList,varIndex[0],dly)
      ppList = ucsRun:setPPAmplitude(ppList,varIndex[1],amp)

    # Initialise FID array
      sumData = cmatrix(totPnts)  
   
   # Accumulate scan
      for(scan = 0 to nrScans-1)
     
       # Set phases for this scan
         (ppList,pAcq) = ucsRun:setPPPhase(ppList,scan,pcList,pcIndex)
   
       # Send phase parameters to DSP
         dspwrite("x",0x00,ppList)

       # Wait for the repetition time to complete
         check = ucsRun:checkTiming(guipar,scan,pcList)
         if(check == "abort")
            return(0)
         endif

       # Collect the data
         ucsUtilities:suspendLock # turn lock control loop off
        (status,data) = ucsRun:getData(totPnts,guipar)
         ucsUtilities:resumeLock  # turn lock control loop on

       # See if stop button/escape key pressed
         if(status != "ok")
            return(0)
         endif

       # Shift the data to minimise p1
         data = shift(data,round(shiftPoints))

       # Correct the distortions in start of FID due to digital filter 
         data = ucsUtilities:correctFilter1(data,dwellTime)

       # Accumlate the data
         sumData = ucsRun:accumulate(accumulate,pAcq,sumData,data)

       # Process data
         (phasedTimeData, spectrum) = ucsRun:transformData(zerofill(sumData.*flt,zf*totPnts,"end"),fAxis,guipar,"fid")
   
       # Simple offset baseline correction
         spectrum = ucsRun:baselineCorrection(spectrum,"offset",32)
        
       # Plot the data 
         if(d == -2)
            titleTxt = "Reference scans: SCANS"
         elseif(d == -1)
            titleTxt = "Short time dummy/phase scan : Delay = $tm,2.2f$ ms SCANS"
         else
            titleTxt = "Echo sum : Delay = $tm,2.2f$ ms SCANS"
         endif
         ucsPlot:graphTimeAndFreq(prt,prf,tAxis,sumData,fAxisDisp,spectrum*pc,scan,guipar,
                                  titleTxt,"Spectrum",
                                  "Time (ms)","Amplitude (\G(m)V)",
                                  fAxisLabel,"Amplitude (\G(m)V/Hz)")

         if(check == "finish")
            scan = scan+1
            exitfor()
         endif

      next(scan) # End of scan loop

   # On the long time delay scan get maximum echo amplitude and measure reference phase
      if((d == -2) | (d == -1)) # & convertToExp == "no")) 

         if(autoPhase == "yes")
            ph = autoPhase1D(spectrum,5)
           # if(convertToExp == "no")
               ph = ph-180
            #endif
            try # Update the receiver phase
               n = findobj(0,"name","rxPhase")
               newPhase = (eval(getpar(0,n,"text"))+ph)%360
               setpar(0,n,"text",newPhase)  
            catch; endtry;
            pc = exp(i*ph/180*pi)
         else
            pc = 1
         endif

#         if(convertToExp == "yes" & d == -2)
#            longTimeSpectrum = pc*spectrum
#         endif

   # On normal scans integrate the data
      elseif(d >= 0) 

       # Record the phase corrected results
         gShared->spec2d[~,d] = spectrum*pc
         data2d[~,d] = sumData

       # Plot the spectra
         yRange = [minDelay,maxDelay]*1e-3
         StackedPlot(prs, gShared->spec2d, d, fRange, fAxisDisp, "yes", yRange, 
                          delaySpacing, fAxisLabel, "T1IR_1H_Exp4 delay (s)","T1IR_1H_Exp4 spectra")

       # Plot the integrals with a fit. Shared parameters allow for dynamic integral selection
         gShared->integralStep = d
         IntegrateRegions:drawIntegrals(prs,pri,"T1IR_1H_Exp4IR")

      endif

   # Finishing? Then exit amplitude loop
      if(check == "finish")
         exitfor()
      endif

   next(d)

# Save the data
   ucsFiles:savePlot(prs,:getPlotInfo("pt3"),guipar,"noReport")
   ucsFiles:savePlot(pri,:getPlotInfo("pt4"),guipar,"noReport")
   ucsFiles:saveMNovaData(data2d,"data.2d",guipar,"simpleReport",ph)

# Save the processing parameters
   :saveProcPar(guipar,fRange,yRange)

# Remove the shared variable
   rmvar("gShared")

# Pack the data for return
   result = struct()
   result->delays = echoDelay
   result->integrals = echoInt

# Return the results
   return(result)

endproc("execpp")

########################################################
# Get the name of a plot file given the region name
# or return the whole list
########################################################

procedure(getPlotInfo,plotRegion)

   info = ["pt3","T1IR_1H_Exp4IR-Spectra.pt1",
           "pt4","T1IR_1H_Exp4IR-Bulk.pt1"]

   if(plotRegion == "all")
      return(info)
   endif

   idx = getlistindex(info,plotRegion)
   if(idx != -1)
      return(info[idx+1])
   endif

endproc(null)

########################################################
# Return expected experiment duration
########################################################

procedure(expectedDuration, guipar)

   assignstruct(guipar)

  # if(convertToExp == "yes")
  #    nrDummys = 2
   #else
      nrDummys = 1
  # endif

   totScans = (nrSteps+nrDummys)*nrScans + useStartDelay
   duration = (totScans*repTime)/1000

endproc(duration)

#################################
# Save the processing parameters
#################################

procedure(saveProcPar,guipar,xrange,yrange)

   assignlist(guipar)

   if(usePPMScale == "yes")
      xrange = xrange*single(b1Freq1H)
   endif

   procpar = ["f1PPMOffset = $centerFreqPPM$",
              "plotWidth = $xrange[1]-xrange[0]$",
              "plotStart = $xrange[0]$",
              "plotWidth2 = $yrange[1]-yrange[0]$",
              "plotStart2 = $yrange[0]$"]

   cd("$dataDirectory$\\$expName$")
   if(isfile("proc.par"))
      par = load("proc.par")
      procpar = mergelists(procpar,par)
   endif
   save("proc.par",sortlist(procpar),"truedoubles")

   if(isfile("proc_temp.par"))
      rmfile("proc_temp.par")
   endif

endproc()
